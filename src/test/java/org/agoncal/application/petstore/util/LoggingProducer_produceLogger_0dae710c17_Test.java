// Test generated by RoostGPT for test java-scenario-test using AI Type Open AI and AI Model gpt-4

/*
1. Scenario: Test if the function returns a logger instance when a valid InjectionPoint is provided.
   - Given a valid InjectionPoint object
   - When the function produceLogger is called with this InjectionPoint
   - Then it should return a Logger instance

2. Scenario: Test if the function returns a Logger with the correct class name.
   - Given a valid InjectionPoint object from a specific class
   - When the function produceLogger is called with this InjectionPoint
   - Then the Logger's name should match the class name from the InjectionPoint

3. Scenario: Test if the function reacts properly when a null InjectionPoint is provided.
   - Given a null InjectionPoint
   - When the function produceLogger is called with this InjectionPoint
   - Then it should throw a NullPointerException or return a default Logger

4. Scenario: Test if the function returns a Logger with the fully qualified class name.
   - Given a valid InjectionPoint object from a specific class in a specific package
   - When the function produceLogger is called with this InjectionPoint
   - Then the Logger's name should match the fully qualified class name from the InjectionPoint

5. Scenario: Test if the function returns different Logger instances for different classes.
   - Given two valid InjectionPoint objects from different classes
   - When the function produceLogger is called with each InjectionPoint
   - Then it should return two different Logger instances

6. Scenario: Test if the function returns the same Logger instance for the same class.
   - Given two valid InjectionPoint objects from the same class
   - When the function produceLogger is called with each InjectionPoint
   - Then it should return the same Logger instance

7. Scenario: Test if the function returns a Logger instance when an InjectionPoint from an anonymous class is provided.
   - Given a valid InjectionPoint object from an anonymous class
   - When the function produceLogger is called with this InjectionPoint
   - Then it should return a Logger instance with the anonymous class name

8. Scenario: Test if the function returns a Logger instance when an InjectionPoint from an inner class is provided.
   - Given a valid InjectionPoint object from an inner class
   - When the function produceLogger is called with this InjectionPoint
   - Then it should return a Logger instance with the inner class name
*/
package org.agoncal.application.petstore.util;

import javax.enterprise.inject.spi.InjectionPoint;
import java.util.logging.Logger;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.junit.MockitoJUnitRunner;
import org.mockito.InjectMocks;
import static org.mockito.Mockito.*;
import static org.junit.Assert.*;

@RunWith(MockitoJUnitRunner.class)
public class LoggingProducer_produceLogger_0dae710c17_Test {

    @Mock
    InjectionPoint injectionPoint;

    @InjectMocks
    LoggingProducer loggingProducer;

    @Test
    public void testProduceLogger_ValidInjectionPoint() {
        when(injectionPoint.getMember().getDeclaringClass().getName()).thenReturn("org.agoncal.application.petstore.util.LoggingProducer_produceLogger_0dae710c17_Test");
        Logger producedLogger = loggingProducer.produceLogger(injectionPoint);

        assertNotNull(producedLogger);
        assertEquals("org.agoncal.application.petstore.util.LoggingProducer_produceLogger_0dae710c17_Test", producedLogger.getName());
    }

    @Test
    public void testProduceLogger_NullInjectionPoint() {
        try {
            Logger producedLogger = loggingProducer.produceLogger(null);
            fail("Expected an IllegalArgumentException to be thrown");
        } catch (IllegalArgumentException e) {
            assertEquals("InjectionPoint cannot be null", e.getMessage());
        }
    }
}
